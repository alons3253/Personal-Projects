# updated to full functionality

import pandas as pd
import requests
from win10toast import ToastNotifier
from requests import get
import websocket
from json import loads
import threading as th
import alpaca_trade_api as trade_api
import datetime as dt
from clr import AddReference
from pandas import DataFrame
import openpyxl
import win32com.client as win32
import os
from bs4 import BeautifulSoup
import numpy as np
import time
import sys

from ALGO.stock_analyzer import APIbootstrap


def on_message(ws, message):
    if message == '{"type":"ping"}':
        return
    DATA = loads(message)
    stock_fundamentals = DATA['data'][0]
    time_integer = stock_fundamentals['t']
    timestamp = dt.datetime.fromtimestamp(time_integer / 1e3)
    timestamp = str("{}.{:03d}".format(timestamp.strftime('%Y-%m-%d %H:%M:%S'), timestamp.microsecond // 1000))
    stock_fundamentals['t'] = timestamp
    s = stock_fundamentals['s']
    stock_fundamentals['time'] = stock_fundamentals.pop('t')
    stock_fundamentals['price'] = stock_fundamentals.pop('p')
    stock_fundamentals['stock'] = stock_fundamentals.pop('s')
    stock_fundamentals['volume'] = stock_fundamentals.pop('v')
    print(stock_fundamentals)
    trade_data[s].append(stock_fundamentals)


def on_error(ws, error):
    print(error)


def on_close(ws):
    print("### closed ###")


def on_open(ws):
    for stock_ticker in stock_tickers:
        custom_call = str('{"type":"subscribe","symbol":"') + stock_ticker + str('"}')
        print(custom_call)
        ws.send(custom_call)


def stock_data_engine():
    AddReference(r"C:\Users\fabio\source\repos\Webscraper Class Library\Webscraper Class Library\bin\Debug\Web"
                 r"scraper Class Library.dll")
    import CSharpwebscraper
    scrape_client = CSharpwebscraper.Webscraper()
    scraped_stock_info = scrape_client.Scraper(stock_tickers)
    print(scraped_stock_info)
    quote = {}
    for ITEM_POS in range(len(scraped_stock_info)):
        if (ITEM_POS % 6) == 0:
            quote['current price'] = float(scraped_stock_info[ITEM_POS].replace(",", ""))
        if (ITEM_POS % 6) == 1:
            quote['open price'] = float(scraped_stock_info[ITEM_POS].replace(",", ""))
        if (ITEM_POS % 6) == 2:
            quote['previous close'] = float(scraped_stock_info[ITEM_POS].replace(",", ""))
        if (ITEM_POS % 6) == 3:
            quote['indicator'] = str(scraped_stock_info[ITEM_POS])
        if (ITEM_POS % 6) == 4:
            delimiter1 = '('
            delimiter2 = ')'
            div = str(scraped_stock_info[ITEM_POS])
            dividend = div[div.find(delimiter1) + 1: div.find(delimiter2)]
            if dividend == 'N/A':
                dividend = 0
            else:
                div_string = dividend.split("%")[0]
                dividend = float(div_string) / 100
            quote['dividend'] = dividend
        if (ITEM_POS % 6) == 5:
            st = str(scraped_stock_info[ITEM_POS])
            quote['stock'] = st
            quote['time'] = dt.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            quote_data[st].append(quote)
            quote = {}
            df_quote = DataFrame(quote_data[st])
            df_quote.set_index('time', inplace=True)
            print(df_quote)


def tech_indicators():
    resolution = ['1', '5', '15', '30', '60', 'D', 'W', 'M']
    for st in stock_tickers:
        TIME_PERIOD = 0
        while True:
            try:
                timestamp_tech = time.strftime("%Y-%m-%d %H:%M:%S")
                tech_url = 'https://finnhub.io/api/v1/scan/technical-indicator?symbol=' + st + \
                           '&resolution=' + resolution[TIME_PERIOD] + '&token=bsq43v0fkcbdt6un6ivg'
                r = get(tech_url)
                ti = r.json()
                technical = ti['technicalAnalysis']['count']
                technical['signal'] = ti['technicalAnalysis']['signal']
                technical['adx'] = ti['trend']['adx']
                technical['trending'] = ti['trend']['trending']
                technical['time'] = timestamp_tech
                ti_data[st].append(technical)
                df_tech = DataFrame(ti_data[st])
                df_tech.set_index('signal', inplace=True)
                print(df_tech)
            except KeyError:
                if TIME_PERIOD == 7:
                    break
                TIME_PERIOD += 1
            break


def main_data_engine():
    try:
        t1 = th.Thread(target=socket.run_forever)
        t1.daemon = True
        t1.start()
        t2 = th.Thread(target=stock_data_engine)
        t2.daemon = True
        t2.start()
        t3 = th.Thread(target=tech_indicators)
        t3.daemon = True
        t3.start()
        time.sleep(15)
        t2.join()
        t3.join()
        socket.keep_running = False
        socket.close()
        t1.join()
    except Exception as error:
        print(error)
        socket.close()


def ticker_operations():
    for STOCK_TICKER in stock_tickers:
        timestamp = dt.datetime.strptime(quote_data[STOCK_TICKER][-1]['time'][11::], '%H:%M:%S').time()
        indicator = quote_data[STOCK_TICKER][-1]['indicator']
        if len(ti_data) > 0:
            buy_votes = int(ti_data[STOCK_TICKER][-1]['buy'])
            sell_votes = int(ti_data[STOCK_TICKER][-1]['sell'])
            neutral_votes = int(ti_data[STOCK_TICKER][-1]['neutral'])
            indicator_votes[STOCK_TICKER]['Bullish Votes'] += buy_votes
            indicator_votes[STOCK_TICKER]['Bearish Votes'] += sell_votes
            indicator_votes[STOCK_TICKER]['Neutral Votes'] += neutral_votes

        if indicator == 'Bullish':
            indicator_votes[STOCK_TICKER]['Bullish Votes'] += 1
        if indicator == 'Bearish':
            indicator_votes[STOCK_TICKER]['Bearish Votes'] += 1

        if indicator_votes[STOCK_TICKER]['Bullish Votes'] > indicator_votes[STOCK_TICKER]['Bearish Votes'] and \
                indicator_votes[STOCK_TICKER]['Bullish Votes'] > indicator_votes[STOCK_TICKER]['Neutral Votes']:
            stock_buylist[STOCK_TICKER].append('Very Bullish at: ' + str(timestamp))
        elif indicator_votes[STOCK_TICKER]['Bullish Votes'] > indicator_votes[STOCK_TICKER]['Bearish Votes']:
            stock_buylist[STOCK_TICKER].append('Bullish at: ' + str(timestamp))

        if indicator_votes[STOCK_TICKER]['Bearish Votes'] > indicator_votes[STOCK_TICKER]['Bullish Votes'] and \
                indicator_votes[STOCK_TICKER]['Bearish Votes'] > indicator_votes[STOCK_TICKER]['Neutral Votes']:
            stock_shortlist[STOCK_TICKER].append('Very Bearish at: ' + str(timestamp))
        elif indicator_votes[STOCK_TICKER]['Bearish Votes'] > indicator_votes[STOCK_TICKER]['Bullish Votes']:
            stock_shortlist[STOCK_TICKER].append('Bearish at: ' + str(timestamp))

    print('Stocks of interest:', stock_tickers)
    print('Buy Side Stocklist:', stock_buylist)
    print('Sell Side Stocklist:', stock_shortlist)
    print('------------------------------------------------------------------------')


def volume_operations():
    for STOCK_TICKER in stock_tickers:
        volume_past_30sec = 0
        volume_past_min = 0
        volume_past_2min = 0
        volume_past_5min = 0
        stock_price = 0
        stock_list_length[STOCK_TICKER] = 0
        length = []
        stock_prices[STOCK_TICKER] = []
        for pos, ite in enumerate(trade_data[STOCK_TICKER]):
            if pos >= int(len(trade_data[STOCK_TICKER]) - 25):
                stock_price += ite['price']
                length.append(ite)
                stock_list_length[STOCK_TICKER] = int(len(length))
            ##############################################################################
            tradetime = dt.datetime.strptime(ite['time'], "%Y-%m-%d %H:%M:%S.%f")
            if tradetime > dt.datetime.now() - dt.timedelta(seconds=30):
                volume_past_30sec += int(ite['volume'])
            if tradetime > dt.datetime.now() - dt.timedelta(seconds=60):
                volume_past_min += int(ite['volume'])
            if tradetime > dt.datetime.now() - dt.timedelta(seconds=120):
                volume_past_2min += int(ite['volume'])
            if tradetime > dt.datetime.now() - dt.timedelta(seconds=300):
                volume_past_5min += int(ite['volume'])
        ##############################################################################
        try:
            stock_prices[STOCK_TICKER] = float("{:.3f}".format(stock_price / stock_list_length[STOCK_TICKER]))
        except ZeroDivisionError:
            stock_prices[STOCK_TICKER] = quote_data[STOCK_TICKER][-1]['current price']
            pass
        volume_terms[STOCK_TICKER] = volume_past_30sec, volume_past_min, volume_past_2min, volume_past_5min
        ##############################################################################
    print('volume by stock ordered 30sec, 1min, 2min and 5min:', volume_terms)
    print('stock prices:', stock_prices)


# might need rework and additional analysis
def analysis_operations():
    # this block is only to see if the stock has had an increase or decrease in short term price respectively
    # if the following conditions are met, then this represents a good trade opportunity
    # this portion works
    for sto in stock_buylist:
        for pos, Item in enumerate(quote_data[sto]):
            if dt.datetime.strptime(quote_data[sto][pos]['time'], "%Y-%m-%d %H:%M:%S") > \
                    (dt.datetime.now() - dt.timedelta(minutes=5)):
                if pos == (len(quote_data[sto]) - 1) and quote_data[sto][pos]['current price'] < \
                        stock_prices[sto]:
                    stock_price_movement[sto] = 'short-term increase in price'
    for sto in stock_shortlist:
        for pos, Item in enumerate(quote_data[sto]):
            if dt.datetime.strptime(quote_data[sto][pos]['time'], "%Y-%m-%d %H:%M:%S") > \
                    (dt.datetime.now() - dt.timedelta(minutes=5)):
                # if current price is lower than quote price
                if pos == (len(quote_data[sto]) - 1) and quote_data[sto][pos]['current price'] > \
                        stock_prices[sto]:
                    stock_price_movement[sto] = 'short-term decrease in price'
    print(stock_price_movement)
    ##############################################################################
    for STOCK_QUOTE in stock_price_movement:
        if 'increase' in stock_price_movement[STOCK_QUOTE]:
            if len(stock_buylist[STOCK_QUOTE]) > 2:
                if quote_data[STOCK_QUOTE][-1]['current price'] > quote_data[STOCK_QUOTE][-2]['current price'] > \
                        quote_data[STOCK_QUOTE][-3]['current price']:
                    if 'Very Bullish' in stock_buylist[STOCK_QUOTE][-1] and 'Very Bullish' in \
                            stock_buylist[STOCK_QUOTE][-2]:
                        strong_buy.append(STOCK_QUOTE)
                elif quote_data[STOCK_QUOTE][-1]['current price'] > quote_data[STOCK_QUOTE][-2]['current price']:
                    if 'Bullish' in stock_buylist[STOCK_QUOTE][-1] and 'Bullish' in stock_buylist[STOCK_QUOTE][-2]:
                        buy.append(STOCK_QUOTE)
                else:
                    weak_buy.append(STOCK_QUOTE)
        if 'decrease' in stock_price_movement[STOCK_QUOTE]:
            if len(stock_shortlist[STOCK_QUOTE]) > 2:
                if quote_data[STOCK_QUOTE][-1]['current price'] < quote_data[STOCK_QUOTE][-2]['current price'] < \
                        quote_data[STOCK_QUOTE][-3]['current price']:
                    if 'Very Bearish' in stock_shortlist[STOCK_QUOTE][-1] and 'Very Bearish' in STOCK_QUOTE:
                        strong_sell.append(STOCK_QUOTE)
                elif quote_data[STOCK_QUOTE][-1]['current price'] < quote_data[STOCK_QUOTE][-2]['current price']:
                    if 'Bearish' in stock_shortlist[STOCK_QUOTE][-1] and 'Bearish' in stock_shortlist[STOCK_QUOTE][-2]:
                        sell.append(STOCK_QUOTE)
                else:
                    weak_sell.append(STOCK_QUOTE)
    ####################################################################################################################
    if len(strong_buy) > 0:
        print('Stock Strong Buy List:', strong_buy)
    if len(buy) > 0:
        print('Stock Buy List:', buy)
    if len(weak_buy) > 0:
        print('Stock Weak Buy List:', weak_buy)
    if len(strong_sell) > 0:
        print('Stock Strong Sell List:', strong_sell)
    if len(sell) > 0:
        print('Stock Sell List:', sell)
    if len(weak_sell) > 0:
        print('Stock Weak Sell List:', weak_sell)


def trade_execution_operations():
    global strong_buy, buy, weak_buy, strong_sell, sell, weak_sell, current_stock_position
    print(api.list_orders())
    block_purchase = []

    if len(api.list_positions()) > 0:
        for stockticker in stock_tickers:
            try:
                stock_position = api.get_position(stockticker)
                print(stock_position)
                position_value = getattr(stock_position, "market_value")
                position_value = abs(float(position_value))
                if position_value >= (0.10 * account_balance):
                    block_purchase.append('block ' + stockticker)
            except Exception as problem:
                print(problem)
                continue

        for opportunity in strong_buy:
            try:
                # for an element in the strong_buy indicator list, if it is equal to the current stock position,
                # then we wont liquidate, if not then we will liquidate
                if opportunity in current_stock_position:
                    continue
                else:
                    # if we have an indicator that is different that we just calculated, we need to remove
                    # the old position and use the new analysis as it is more up to date on the strength of the stock
                    check_orders = api.list_orders(status='open')
                    for order in check_orders:
                        api.cancel_order(order.id)
                    api.close_position(opportunity)
            except Exception as problem:
                print(problem)
                continue

        for opportunity in buy:
            try:
                if opportunity in current_stock_position:
                    continue
                else:
                    check_orders = api.list_orders(status='open')
                    for order in check_orders:
                        api.cancel_order(order.id)
                    api.close_position(opportunity)
            except Exception as problem:
                print(problem)
                continue

        for opportunity in weak_buy:
            try:
                if opportunity in current_stock_position:
                    continue
                else:
                    check_orders = api.list_orders(status='open')
                    for order in check_orders:
                        api.cancel_order(order.id)
                    api.close_position(opportunity)
            except Exception as problem:
                print(problem)
                continue

        for opportunity in strong_sell:
            try:
                if opportunity in current_stock_position:
                    continue
                else:
                    check_orders = api.list_orders(status='open')
                    for order in check_orders:
                        api.cancel_order(order.id)
                    api.close_position(opportunity)
            except Exception as problem:
                print(problem)
                continue

        for opportunity in sell:
            try:
                if opportunity in current_stock_position:
                    continue
                else:
                    check_orders = api.list_orders(status='open')
                    for order in check_orders:
                        api.cancel_order(order.id)
                    api.close_position(opportunity)
            except Exception as problem:
                print(problem)
                continue

        for opportunity in weak_sell:
            try:
                if opportunity in current_stock_position:
                    continue
                else:
                    check_orders = api.list_orders(status='open')
                    for order in check_orders:
                        api.cancel_order(order.id)
                    api.close_position(opportunity)
            except Exception as problem:
                print(problem)
                continue

    #################################################################################################################
    # check orders and see if they should be sold, if we have idle bracket orders with a small fluctuating profit/loss
    # just close them out
    """
    for element in stock_tickers:
        api.list_positions()
        for stockposition in api.list_positions():
            if float(getattr(stockposition, "unrealized_intraday_plpc")) > 0.001:
                check_orders = api.list_orders(status='open')
                for order in check_orders:
                    api.cancel_order(order.id)
                api.close_position(element)
    """

    #################################################################################################################
    AddReference(r"C:\Users\fabio\source\repos\Main Trade Executor Class Library\Main Trade Executor Class Lib"
                 r"rary\bin\Release\Main Trade Executor Class Library.dll")
    import CSharpTradeExecutor
    trader = CSharpTradeExecutor.BracketOrders()

    print(block_purchase)

    for opportunity in strong_buy:
        try:
            for pos, it in enumerate(block_purchase):
                if opportunity in block_purchase[pos]:
                    raise Exception('{} Position has exceeded 10% of the portfolio value'.format(opportunity))
            price = stock_prices[opportunity]
            account_percentage = (account_balance * 0.04) // price
            round_lot = int(account_percentage)
            if round_lot == 0:
                round_lot += 1
            stop_loss = 0.9985 * price
            stoplosslimitprice = .9980 * price
            limit_price = 1.002 * price
            args = [opportunity, 'buy', str(round_lot), str(round(stop_loss, 2)), str(round(limit_price, 2)),
                    str(round(stoplosslimitprice, 2))]
            trader.Trader(args)
            notification.show_toast("Program Trades Executed", "Program executed strongbuy trade of {} at {}".format(
                                    opportunity, time.strftime("%H:%M:%S")), duration=4)
            pos = str(opportunity + 'strongbuy')
            current_stock_position.append(pos)
        except Exception as error:
            print('The following error occurred during trade execution:\'{}\''.format(error))
            continue

    for opportunity in buy:
        try:
            for pos, it in enumerate(block_purchase):
                if opportunity in block_purchase[pos]:
                    raise Exception('{} Position has exceeded 10% of the portfolio value'.format(opportunity))
            price = stock_prices[opportunity]
            account_percentage = (account_balance * 0.03) // price
            round_lot = int(account_percentage)
            if round_lot == 0:
                round_lot += 1
            limit_price = 1.0016 * price
            stop_loss = 0.9986 * price
            stoplosslimitprice = 0.9984 * price
            args = [opportunity, 'buy', str(round_lot), str(round(stop_loss, 2)), str(round(limit_price, 2)),
                    str(round(stoplosslimitprice, 2))]
            trader.Trader(args)
            notification.show_toast("Program Trades Executed", "Program executed buy trade of {} at {}".format(
                                    opportunity, time.strftime("%H:%M:%S")), duration=4)
            pos = str(opportunity + 'buy')
            current_stock_position.append(pos)
        except Exception as error:
            print('The following error occurred during trade execution:\'{}\''.format(error))
            continue

    for opportunity in weak_buy:
        try:
            for pos, it in enumerate(block_purchase):
                if opportunity in block_purchase[pos]:
                    raise Exception('{} Position has exceeded 10% of the portfolio value'.format(opportunity))
            price = stock_prices[opportunity]
            account_percentage = (account_balance * 0.025) // price
            round_lot = int(account_percentage)
            if round_lot == 0:
                round_lot += 1
            limit_price = 1.0012 * price
            stop_loss = 0.9988 * price
            stoplosslimitprice = 0.9986 * price
            args = [opportunity, 'buy', str(round_lot), str(round(stop_loss, 2)), str(round(limit_price, 2)),
                    str(round(stoplosslimitprice, 2))]
            trader.Trader(args)
            notification.show_toast("Program Trades Executed", "Program executed weakbuy trade of {} at {}".format(
                                    opportunity, time.strftime("%H:%M:%S")), duration=4)
            pos = str(opportunity + 'weakbuy')
            current_stock_position.append(pos)
        except Exception as error:
            print('The following error occurred during trade execution:\'{}\''.format(error))
            continue

    # short trades
    for opportunity in strong_sell:
        try:
            for pos, it in enumerate(block_purchase):
                if opportunity in block_purchase[pos]:
                    raise Exception('{} Position has exceeded 10% of the portfolio value'.format(opportunity))
            price = stock_prices[opportunity]
            account_percentage = (account_balance * 0.04) // price
            round_lot = int(account_percentage)
            if round_lot == 0:
                round_lot += 1
            limit_price = .998 * price
            stop_loss = 1.0015 * price
            stoplosslimitprice = 1.0020 * price
            args = [opportunity, 'sell', str(round_lot), str(round(stop_loss, 2)), str(round(limit_price, 2)),
                    str(round(stoplosslimitprice, 2))]
            trader.Trader(args)
            notification.show_toast("Program Trades Executed", "Program executed strongsell trade of {} at {}".format(
                                    opportunity, time.strftime("%H:%M:%S")), duration=4)
            pos = str(opportunity + 'strongsell')
            current_stock_position.append(pos)
        except Exception as error:
            print('The following error occurred during trade execution:\'{}\''.format(error))
            continue

    for opportunity in sell:
        try:
            for pos, it in enumerate(block_purchase):
                if opportunity in block_purchase[pos]:
                    raise Exception('{} Position has exceeded 10% of the portfolio value'.format(opportunity))
            price = stock_prices[opportunity]
            account_percentage = (account_balance * 0.03) // price
            round_lot = int(account_percentage)
            if round_lot == 0:
                round_lot += 1
            limit_price = .9984 * price
            stop_loss = 1.0012 * price
            stoplosslimitprice = 1.0016 * price
            args = [opportunity, 'sell', str(round_lot), str(round(stop_loss, 2)), str(round(limit_price, 2)),
                    str(round(stoplosslimitprice, 2))]
            trader.Trader(args)
            notification.show_toast("Program Trades Executed", "Program executed sell trade of {} at {}".format(
                                    opportunity, time.strftime("%H:%M:%S")), duration=4)
            pos = str(opportunity + 'sell')
            current_stock_position.append(pos)
        except Exception as error:
            print('The following error occurred during trade execution:\'{}\''.format(error))
            continue

    for opportunity in weak_sell:
        try:
            for pos, it in enumerate(block_purchase):
                if opportunity in block_purchase[pos]:
                    raise Exception('{} Position has exceeded 10% of the portfolio value'.format(opportunity))
            price = stock_prices[opportunity]
            account_percentage = (account_balance * 0.025) // price
            round_lot = int(account_percentage)
            if round_lot == 0:
                round_lot += 1
            limit_price = .9988 * price
            stop_loss = 1.0010 * price
            stoplosslimitprice = 1.0012 * price
            args = [opportunity, 'sell', str(round_lot), str(round(stop_loss, 2)), str(round(limit_price, 2)),
                    str(round(stoplosslimitprice, 2))]
            trader.Trader(args)
            notification.show_toast("Program Trades Executed", "Program executed weaksell trade of {} at {}".format(
                                    opportunity, time.strftime("%H:%M:%S")), duration=4)
            pos = str(opportunity + 'weaksell')
            current_stock_position.append(pos)
        except Exception as error:
            print('The following error occurred during trade execution:\'{}\''.format(error))
            continue


def check_trades():
    if len(trade_data) == 0:
        print('No trades were gathered')
        return False
    return True


def cleanup():
    # get rid of elements in lists that are dated 5 minutes and beyond to save memory
    if (end - start) > 300:
        for STOCK in stock_tickers:
            for p, it in enumerate(trade_data[STOCK]):
                if dt.datetime.strptime(it['time'], "%Y-%m-%d %H:%M:%S.%f") < dt.datetime.now() - \
                        dt.timedelta(seconds=300):
                    trade_data[STOCK].remove(it)
            for p, it in enumerate(quote_data[STOCK]):
                if dt.datetime.strptime(it['time'], "%Y-%m-%d %H:%M:%S") < dt.datetime.now() - \
                        dt.timedelta(seconds=300):
                    quote_data[STOCK].remove(it)
            for p, it in enumerate(ti_data[STOCK]):
                if dt.datetime.strptime(it['time'], "%Y-%m-%d %H:%M:%S") < dt.datetime.now() - \
                        dt.timedelta(seconds=300):
                    ti_data[STOCK].remove(it)


def check_for_market_close():
    if not clock.is_open:
        raise Exception('The market is currently closed')

    tmp_fivemintime = dt.datetime.combine(dt.date(1, 1, 1), market_close)
    fiveminfromclose = (tmp_fivemintime - dt.timedelta(minutes=5)).time()

    # since the 'close' object is timezone aware, we should not have to make any
    # specific conditionals checking for timezones
    if dt.datetime.now().time() > fiveminfromclose:
        raise Exception('The market is closing in 5 minutes, all positions have been closed')


"""
END OF ALGO TRADER
"""


def data_to_excel(metrics):
    book = openpyxl.load_workbook('Portfolio Data.xlsx')
    excel_writer = pd.ExcelWriter('Portfolio Data.xlsx', engine='openpyxl')
    excel_writer.book = book
    excel_writer.sheets = dict((ws.title, ws) for ws in book.worksheets)
    metrics.to_excel(excel_writer, sheet_name=sheet_name)
    try:
        sheet = book['Sheet']
        book.remove(sheet)
        book.save('Portfolio Data.xlsx')
    except KeyError:
        pass
    excel_writer.save()


def formatting_excel(name):
    excel = win32.Dispatch('Excel.Application')
    wkb = excel.Workbooks.Open(r"C:\Users\fabio\PycharmProjects\AlgoTrader\Portfolio Data.xlsx")
    ws = wkb.Worksheets(name)
    ws.Columns.AutoFit()
    wkb.Save()
    excel.Application.Quit()


def web_scraping(tickers):
    r = requests.get('https://www.marketwatch.com/investing/bond/tmubmusd01m?countrycode=bx')
    soup = BeautifulSoup(r.text, 'lxml')
    try:
        bond_list = [entry.text for entry in
                     soup.find_all('span', {'class': 'value'})]
        bond_rate = float(bond_list[-1])
        print("1 month risk-free-rate", str(bond_rate) + str('%'))
    except IndexError:
        print("Failed to fetch 1-Month T-bond Yield! Setting to default value (0.01)")
        bond_rate = 0.01

    for url_stock in tickers:
        quote = {}
        stock_url = 'https://finance.yahoo.com/quote/' + url_stock + '?p=' + url_stock
        r = requests.get(stock_url)
        soup = BeautifulSoup(r.text, 'lxml')
        beta_metric = [entry.text for entry in soup.find_all('span', {'data-reactid': '144'})]
        return_pct = [entry.text for entry in soup.find_all('span', {'data-reactid': '51'})]
        delimiter1 = '('
        delimiter2 = ')'
        formatted_return = str(return_pct[0])
        rt = formatted_return[formatted_return.find(delimiter1) + 1: formatted_return.find(delimiter2)]
        return_string = rt.split("%")[0]
        returns = float(return_string)
        print(url_stock, returns)
        quote['stock'] = url_stock
        quote['beta'] = beta_metric[0]
        quote['returns'] = round(returns, 4)
        quote_data[url_stock] = quote
    # spy
    r = requests.get('https://finance.yahoo.com/quote/SPY?p=SPY')
    soup = BeautifulSoup(r.text, 'lxml')
    spy_returns_pct = [entry.text for entry in soup.find_all('span', {'data-reactid': '51'})]
    delimiter1 = '('
    delimiter2 = ')'
    formatted_return = str(spy_returns_pct[0])
    rt = formatted_return[formatted_return.find(delimiter1) + 1: formatted_return.find(delimiter2)]
    return_string = rt.split("%")[0]
    spy_returns = float(return_string)

    return spy_returns, bond_rate


def purchasing_filter(purchases_df):
    long_purchases_df = purchases_df.loc[(purchases_df['side'] == 'buy') & (purchases_df['cumulative_sum'] > 0)]
    total_long_purchases = round(long_purchases_df['net_trade'].sum(), 2)
    print("Gross cost of long positions:", total_long_purchases)

    short_purchases_df = purchases_df.loc[(purchases_df['side'] == 'buy') & (purchases_df['cumulative_sum'] <= 0)]
    total_short_purchases = round(short_purchases_df['net_trade'].sum(), 2)
    print("Gross cost of short positions:", total_short_purchases)

    long_sales_df = purchases_df.loc[purchases_df['side'] == 'sell']
    total_long_sells = round(long_sales_df['net_trade'].sum(), 2)
    print("Gross profit of long positions:", total_long_sells)

    short_sales_df = purchases_df.loc[purchases_df['side'] == 'sell_short']
    total_short_sells = round(short_sales_df['net_trade'].sum(), 2)
    print("Gross profit of short positions:", total_short_sells)


# minor date functions
def suffix(d):
    return 'th' if 11 <= d <= 13 else {1: 'st', 2: 'nd', 3: 'rd'}.get(d % 10, 'th')


def custom_strftime(time_format, t):
    return t.strftime(time_format).replace('{S}', str(t.day) + suffix(t.day))


def bootstrapper():
    # Alpaca API Bootstrap
    token_file = open("alpaca_keys.txt")
    keys = token_file.readlines()
    alpaca_api = trade_api.REST(keys[0], keys[1], "https://paper-api.alpaca.markets", api_version='v2')

    # Finnhub API Bootsrap
    websocket.enableTrace(True)
    web_socket_url = "wss://ws.finnhub.io?token=bsq43v0fkcbdt6un6ivg"
    finnhub_websocket = websocket.WebSocketApp(web_socket_url, on_message=on_message, on_error=on_error,
                                               on_close=on_close)
    finnhub_websocket.on_open = on_open

    return alpaca_api, finnhub_websocket


def time_initialization():
    fulltimezone = str(dt.datetime.now(dt.timezone.utc).astimezone().tzinfo)
    local_timezone = ''.join([c for c in fulltimezone if c.isupper()])
    proper_date = custom_strftime('%B {S}, %Y', dt.datetime.now())
    print('Today\'s date:', proper_date)
    proper_time = dt.datetime.strftime(dt.datetime.now(), "%I:%M:%S %p")
    print('The time is:', proper_time, local_timezone)

    cstdelta = dt.timedelta(hours=1)
    market_close = (clock.next_close - cstdelta).time()
    # the # command in the string truncates leading zeroes
    mkt_close_time_ampm = market_close.strftime("%#I:%M %p")

    mkt_open_date = custom_strftime('%B {S}, %Y', clock.next_open)
    mkt_open_time = (clock.next_open - cstdelta).time()
    market_open_time_ampm = mkt_open_time.strftime("%#I:%M %p")

    if not clock.is_open:
        print('The stock market is currently closed, but will reopen on:')
        print(mkt_open_date + ' at ' + market_open_time_ampm + ' ' + local_timezone)
        market_closed_boolean = True
    else:
        print('The stock market closes at ' + mkt_close_time_ampm + ' today')

    return market_close


if __name__ == '__main__':
    notification = ToastNotifier()

    api, socket = bootstrapper()
    account = api.get_account()
    clock = api.get_clock()

    account_balance = float(account.buying_power) / 4
    print('Trading account status:', account.status)
    print('Current account balance (without margin) is: $' + str(round(account_balance, 2)))

    market_close = time_initialization()

    market_closed_boolean = False
    manual_override_bool = False
    if input("Manual override? (y/n)") == 'y':
        manual_override_bool = True

    if not market_closed_boolean or manual_override_bool:
        print("Select from one of the following choices:")
        print('Press 1 for Automated Stock Fetch and Trading')
        print('Press 2 for Manual Stock Fetch and Automated Trading')
        print('Press 3 for Portfolio Analysis')
        print('This program is developed solely by Anthony M. Lonsdale')
        print('Contact Information:')
        print('E-mail: alons3253@gmail.com')
        print('Cell: 816-872-7762')

        choice = None
        while True:
            try:
                choice = int(input('Enter: '))
                if choice > 3:
                    raise ValueError
            except ValueError:
                print('Invalid input')
                continue
            else:
                break

        stock_tickers = []
        if choice == 1:
            try:
                stock_tickers = APIbootstrap().get_tickers(api)
            except Exception as e:
                print(e)
                choice = 2
        if choice == 2:
            print("Input stock tickers separated by a space, the quotes and trades for each stock will be streamed")
            print("When you are done entering tickers, press Enter to show the quotes for each stock in order")
            print("Type 'close' in order to close all current positions")
            stock_tickers = input('Enter Ticker(s): ').upper().split()

            while True:
                try:
                    if stock_tickers == ['CLOSE']:
                        api.cancel_all_orders()
                        api.close_all_positions()
                        stock_tickers = input('Positions have been closed, Enter Ticker(s): ').upper().split()

                    for position, item in enumerate(stock_tickers):
                        try:
                            asset = api.get_asset(item)
                            if not asset.tradable:
                                print(item, 'is not available to trade on Alpaca!')
                                stock_tickers[position] = input('Enter different ticker: ').upper()
                            continue
                        except Exception as e:
                            print(e)
                            print(stock_tickers[position], 'is not a valid ticker!')
                            stock_tickers[position] = input('Enter a different ticker: ').upper()

                    for stock in stock_tickers:
                        try:
                            asset = api.get_asset(stock)
                            if not asset.tradable:
                                raise Exception("Not Tradable")
                        except Exception:
                            raise Exception("Not Tradable")
                    break
                except Exception as stockinputerror:
                    print(stockinputerror)
                    print("There was a problem with the ticker(s) that you entered")
                    continue
        else:
            pass
        if choice == 1 or choice == 2:
            while True:
                start = time.time()
                stock_buylist = {}
                stock_shortlist = {}
                stock_prices = {}
                volume_terms = {}
                trade_data = {}
                ti_data = {}
                quote_data = {}
                stock_list_length = {}
                indicator_votes = {}
                current_stock_position = []
                stock_price_movement = {}
                cutoff_bool = False
                errormessage_market_close = 'The market is currently closed'
                errormessage_5min_to_close = 'The market is closing in 5 minutes, be warned that any new positions ' \
                                             'may be held until the next trading day'
                errormessage_trade_fetch = 'No trades gathered'
                for ticker in stock_tickers:
                    indicator_votes[ticker] = {'Bullish Votes': 0, 'Bearish Votes': 0, 'Neutral Votes': 0}
                    trade_data[ticker] = []
                    ti_data[ticker] = []
                    quote_data[ticker] = []
                    stock_buylist[ticker] = []
                    stock_shortlist[ticker] = []
                    stock_price_movement[ticker] = ''
                #######################################################################################################
                while True:
                    try:
                        strong_buy = []
                        buy = []
                        weak_buy = []
                        weak_sell = []
                        sell = []
                        strong_sell = []
                        tradethread = th.Thread(target=trade_execution_operations)
                        tradethread.daemon = True
                        check_for_market_close()
                        main_data_engine()
                        print('Trades:', trade_data)
                        print('Quotes:', quote_data)
                        print('Indicators:', ti_data)
                        if not check_trades():
                            print('Warning, No trades gathered! Program terminating...')
                            raise Exception("No trades gathered")
                        ##############################
                        ticker_operations()
                        volume_operations()
                        analysis_operations()
                        tradethread.start()
                        end = time.time()
                        print('Time Elapsed (in seconds):', int((end - start)))
                        cleanup()
                        tradethread.join()
                    except Exception as e:
                        e = str(e)
                        print(e)
                        time.sleep(0.5)
                        if e == errormessage_market_close or e == errormessage_5min_to_close:
                            api.close_all_positions()
                            api.cancel_all_orders()
                            cutoff_bool = True
                            break
                        if e == errormessage_trade_fetch or ZeroDivisionError:
                            break
                        else:
                            notification.show_toast("Program Critical Error", "Program Raised Error {}".format(e),
                                                    duration=5)
                            print('All pending orders will be cancelled and all positions will be liquidated')
                            api.cancel_all_orders()
                            api.close_all_positions()
                if cutoff_bool:
                    break

    # START OF PORTFOLIO ANALYSIS
    if not os.path.isfile(r"C:\Users\fabio\PycharmProjects\AlgoTrader\Portfolio Data.xlsx"):
        wb = openpyxl.Workbook()
        wb.save('Portfolio Data.xlsx')

    pd.options.mode.chained_assignment = None
    days = 0
    activities_df = None
    open_tickers = None
    open_position_catalog = None

    while True:
        try:
            spec_date = dt.datetime.today() - dt.timedelta(days=days)
            date = spec_date.strftime('%Y-%m-%d')
            print('Attempting to analyze portfolio on {}'.format(date))
            activities = api.get_activities(activity_types='FILL', date=date)
            activities_df = pd.DataFrame([activity._raw for activity in activities])
            if not len(activities_df) > 10:
                # print(activities_df)
                time.sleep(0.1)
                raise Exception("Not enough trades for analysis")

            print("Analyzing portfolio activities on {}".format(date))
            activities_df = pd.DataFrame([activity._raw for activity in activities])
            activities_df = activities_df.iloc[::-1]
            activities_df[['price', 'qty']] = activities_df[['price', 'qty']].apply(pd.to_numeric)
            activities_df['net_qty'] = np.where(activities_df.side == 'buy', activities_df.qty, -activities_df.qty)
            activities_df['net_trade'] = -activities_df.net_qty * activities_df.price
            activities_df['cumulative_sum'] = activities_df.groupby('symbol')['net_qty'].apply(lambda g: g.cumsum())
            activities_df.to_excel("Portfolio Activities, {}.xlsx".format(date))
            stock_tickers = list(activities_df.symbol.unique())
            print(stock_tickers)

            # check if there were any open positions on the previous day
            try:
                prev_day_spec_date = dt.datetime.today() - dt.timedelta(days=(days+1))
                prev_day_date = prev_day_spec_date.strftime('%Y-%m-%d')
                prev_day_activities = api.get_activities(activity_types='FILL', date=prev_day_date)
                prev_days_activities_df = pd.DataFrame([activity._raw for activity in prev_day_activities])
                prev_days_activities_df = prev_days_activities_df.iloc[::-1]
                prev_days_activities_df[['price', 'qty']] = \
                    prev_days_activities_df[['price', 'qty']].apply(pd.to_numeric)
                prev_days_activities_df['net_qty'] = np.where(prev_days_activities_df.side == 'buy',
                                                              prev_days_activities_df.qty, -prev_days_activities_df.qty)
                prev_days_activities_df['net_trade'] = -prev_days_activities_df.net_qty * prev_days_activities_df.price
                prev_days_activities_df['cumulative_sum'] = prev_days_activities_df.groupby('symbol')['net_qty'].apply(
                                                                                                lambda h: h.cumsum())
                prev_days_activities_df.to_excel("Portfolio Activities, {}.xlsx".format(prev_day_date))

                nonzero_trades = prev_days_activities_df.groupby('symbol').filter(lambda trade: sum(trade.net_qty) != 0)
                open_position_catalog = {}
                open_tickers = nonzero_trades.symbol.unique()
                print(open_tickers)

                nonzero_trades = nonzero_trades.iloc[::-1]
                for stock in open_tickers:
                    boolean_rectified_open_position = False
                    open_position_catalog[stock] = []
                    open_position_qty = nonzero_trades.iloc[0]['cumulative_sum']
                    for index, row in nonzero_trades.copy().iterrows():
                        if boolean_rectified_open_position:
                            break
                        if row.symbol == stock:
                            if row.net_qty == open_position_qty:
                                open_position_catalog[stock].append(row)
                                nonzero_trades = nonzero_trades[nonzero_trades['symbol'] != stock]
                                boolean_rectified_open_position = True
                            else:
                                open_position_qty -= row.net_qty
                                open_position_catalog[stock].append(row)

                for stock in open_tickers:
                    open_position_catalog[stock] = reversed(open_position_catalog[stock])
                    activities_df = pd.concat([pd.DataFrame(open_position_catalog[stock]), activities_df],
                                              ignore_index=True)
            except Exception as e:
                print("Based on the lack of previous days trades, there is probably not an open position")
            break
        except Exception as e:
            if str(e) == str('Not enough trades for analysis'):
                days += 1
            else:
                print('Program ran into the following error while trying to analyze portfolio data:')
                print(e)
                raise sys.exit(0)

    ###################################################################################################################
    # Total Net Profit for Long and Short Trades
    purchasing_filter(activities_df)
    trade_book = {}
    short_trade_book = {}
    short_order_time_held = {}
    long_order_time_held = {}
    for stock in stock_tickers:
        trade_book[stock] = []
        short_trade_book[stock] = []
        short_order_time_held[stock] = []
        long_order_time_held[stock] = []
        trades_list = []
        for index, row in activities_df.iterrows():
            grouped_trades = {}
            if row['symbol'] == stock:
                grouped_trades.update(row)
                trades_list.append(grouped_trades)

        grouped_trades_df = pd.DataFrame(trades_list)
        excel_title = str(stock) + str(' Trades for ') + str(date) + str('.xlsx')
        grouped_trades_df['cumulative_sum'] = grouped_trades_df.groupby('symbol')['net_qty'].apply(lambda h: h.cumsum())
        # grouped_trades_df.to_excel(excel_title)

        # here is where the trades will be settled
        rows_to_drop = []
        length_of_df = grouped_trades_df.index
        for index, row in grouped_trades_df.copy().iterrows():
            if grouped_trades_df['type'][index] == 'partial_fill':
                # noinspection PyTypeChecker
                for i in range((index+1), (len(length_of_df) - 1)):
                    if grouped_trades_df['side'][index] == grouped_trades_df['side'][i]:
                        grouped_trades_df['qty'][i] += grouped_trades_df['qty'][index]
                        grouped_trades_df['net_qty'][i] += grouped_trades_df['net_qty'][index]
                        grouped_trades_df['net_trade'][i] += grouped_trades_df['net_trade'][index]
                        rows_to_drop.append(index)
                        break
        for rowtodrop in rows_to_drop:
            grouped_trades_df = grouped_trades_df.drop(rowtodrop)
        # grouped_trades_df.to_excel('Settled {} Trades, {}.xlsx'.format(stock, date))
        same_side_orders = []
        txn_time1 = None
        net_trade1 = None
        side1 = None
        qty1 = None
        reset_flag = True
        for index, row in grouped_trades_df.copy().iterrows():
            if reset_flag:
                txn_time1 = dt.datetime.strptime(grouped_trades_df['transaction_time'][index], "%Y-%m-%dT%H:%M:%S.%fZ")
                net_trade1 = grouped_trades_df['net_trade'][index]
                side1 = grouped_trades_df['side'][index]
                qty1 = grouped_trades_df['qty'][index]
                same_side_orders.append([txn_time1, net_trade1, qty1, side1])
                reset_flag = False
                continue

            txn_time2 = dt.datetime.strptime(grouped_trades_df['transaction_time'][index], "%Y-%m-%dT%H:%M:%S.%fZ")
            net_trade2 = grouped_trades_df['net_trade'][index]
            side2 = grouped_trades_df['side'][index]
            qty2 = grouped_trades_df['qty'][index]

            if side2 == side1:
                same_side_orders.append([txn_time2, net_trade2, qty2, side2])
            elif side1 == 'sell_short' and side2 == 'buy':
                if qty2 > qty1:
                    for i in range(len(same_side_orders)):
                        profitloss = round(same_side_orders[0][1] + ((net_trade2 / qty2) * same_side_orders[0][2]), 2)
                        short_trade_book[stock].append(profitloss)
                        time_held = (txn_time2 - same_side_orders[0][0]).total_seconds()
                        short_order_time_held[stock].append((time_held, same_side_orders[0][2]))
                        same_side_orders.pop(0)
                else:
                    profitloss = round(same_side_orders[0][1] + net_trade2, 2)
                    short_trade_book[stock].append(profitloss)
                    time_held = (txn_time2 - txn_time1).total_seconds()
                    short_order_time_held[stock].append((time_held, qty2))
                    same_side_orders.pop(0)
            elif side1 == 'buy' and side2 == 'sell':
                if qty2 > qty1:
                    for i in range(len(same_side_orders)):
                        profitloss = round(same_side_orders[0][1] + ((net_trade2 / qty2) * same_side_orders[0][2]), 2)
                        short_trade_book[stock].append(profitloss)
                        time_held = (txn_time2 - same_side_orders[0][0]).total_seconds()
                        long_order_time_held[stock].append((time_held, same_side_orders[0][2]))
                        same_side_orders.pop(0)
                else:
                    profitloss = round(same_side_orders[0][1] + net_trade2, 2)
                    trade_book[stock].append(profitloss)
                    time_held = (txn_time2 - txn_time1).total_seconds()
                    long_order_time_held[stock].append((time_held, qty2))
                    same_side_orders.pop(0)
            if len(same_side_orders) == 0:
                reset_flag = True

    print(trade_book)
    print(short_trade_book)
    print(long_order_time_held)
    print(short_order_time_held)

    total_profit = 0
    profit_per_symbol = {}
    for stock in trade_book:
        profit_per_symbol[stock] = 0
        for element in trade_book[stock]:
            total_profit += float(element)
            profit_per_symbol[stock] += float(element)
        for element in short_trade_book[stock]:
            total_profit += float(element)
            profit_per_symbol[stock] += float(element)
    print(round(total_profit, 2))
    print("Note that there may be a slight discrepancy in calculated prices vs what alpaca's interface shows, \n"
          "This is simply due to the fact this calculation concerns CLOSED trades, and doesnt consider the \n"
          "changing value of stock(s) held")
    ####################################################################################################################
    short_hold_time = 0
    longtime = 0
    longquantity = 0
    long_length = 0
    shorttime = 0
    shortquantity = 0
    short_length = 0

    for stock in stock_tickers:
        for i in range(len(long_order_time_held[stock])):
            longtime += long_order_time_held[stock][i][0]
            longquantity += long_order_time_held[stock][i][1]
            long_length += 1
        for i in range(len(short_order_time_held[stock])):
            shorttime += short_order_time_held[stock][i][0]
            shortquantity += short_order_time_held[stock][i][1]
            short_length += 1

    avg_long_stock_hold_time = round(longtime / longquantity, 2)
    avg_short_stock_hold_time = round(shorttime / shortquantity, 2)
    avg_long_trade_hold_time = round(longtime / long_length, 2)
    avg_short_trade_hold_time = round(shorttime / short_length, 2)
    print("Average stock held for:", round(avg_long_stock_hold_time, 2), 'seconds')
    print("Average short stock held for:", round(avg_short_stock_hold_time, 2), 'seconds')

    avg_total_trade_length = time.strftime("%#M:%S", time.gmtime((avg_short_trade_hold_time +
                                                                  avg_long_trade_hold_time)))
    avg_short_trade_length = time.strftime("%#M:%S", time.gmtime(avg_short_trade_hold_time))
    avg_long_trade_length = time.strftime("%#M:%S", time.gmtime(avg_long_trade_hold_time))

    print("Average long trade held for:", avg_long_trade_length)
    print("Average short trade held for:", avg_short_trade_length)
    ##################################################################
    total_gross_profit = 0
    total_gross_loss = 0
    short_gross_profit = 0
    short_gross_loss = 0
    net_short_profit = 0
    total_short_trades = 0
    short_winning_trades = 0
    short_even_trades = 0
    short_losing_trades = 0

    for stock in short_trade_book:
        for i in range(len(short_trade_book[stock])):
            if short_trade_book[stock][i] > 0:
                short_winning_trades += 1
                short_gross_profit += short_trade_book[stock][i]
                total_gross_profit += short_trade_book[stock][i]
            elif short_trade_book[stock][i] < 0:
                short_losing_trades += 1
                short_gross_loss += short_trade_book[stock][i]
                total_gross_loss += short_trade_book[stock][i]
            else:
                short_even_trades += 1
            total_short_trades += 1
            net_short_profit += short_trade_book[stock][i]

    net_short_profit = round(net_short_profit, 2)
    print("Short-side net profit:", net_short_profit)
    print("Short-side profitable trades:", short_winning_trades)
    print("Short-side even trades:", short_even_trades)
    print("Short-side Losing trades:", short_losing_trades)
    print("Total short-side trades:", total_short_trades)

    # initialization of long variables
    long_gross_profit = 0
    long_gross_loss = 0
    net_long_profit = 0
    total_long_trades = 0
    long_winning_trades = 0
    long_even_trades = 0
    long_losing_trades = 0
    for stock in trade_book:
        for i in range(len(trade_book[stock])):
            if trade_book[stock][i] > 0:
                long_winning_trades += 1
                long_gross_profit += trade_book[stock][i]
                total_gross_profit += trade_book[stock][i]
            elif trade_book[stock][i] < 0:
                long_losing_trades += 1
                long_gross_loss += trade_book[stock][i]
                total_gross_loss += trade_book[stock][i]
            else:
                long_even_trades += 1
            total_long_trades += 1
            net_long_profit += trade_book[stock][i]

    net_long_profit = round(net_long_profit, 2)
    print("\nLong-side net profit:", net_long_profit)
    print("Long-side profitable trades:", long_winning_trades)
    print("Long-side even trades:", long_even_trades)
    print("Long-side losing trades:", long_losing_trades)
    print("Total long-side trades", total_long_trades)

    avg_winning_trade = round((total_gross_profit / (long_winning_trades + short_winning_trades)), 2)
    avg_losing_trade = round((total_gross_loss / (total_long_trades + short_losing_trades)), 2)
    avg_long_winning_trade = round(long_gross_profit / long_winning_trades, 2)
    avg_long_losing_trade = round(long_gross_loss / long_losing_trades, 2)
    avg_short_winning_trade = round(short_gross_profit / short_winning_trades, 2)
    avg_short_losing_trade = round(short_gross_loss / short_losing_trades, 2)

    todays_profit_and_loss = round(total_gross_profit + total_gross_loss, 2)
    total_gross_profit = round(total_gross_profit, 2)
    total_gross_loss = round(total_gross_loss, 2)

    print("\nProfit Metrics:")
    print("Gross Profit:", total_gross_profit)
    print("Average Winning Trade:", avg_winning_trade)
    print("Gross Loss:", total_gross_loss)
    print("Average Losing Trade:", avg_losing_trade)
    print("Total Net Profit:", todays_profit_and_loss)

    #############################################################################
    pd.options.display.float_format = '{:.0f}'.format
    quote_data = {}
    for stock in stock_tickers:
        quote_data[stock] = {}
    #########################################################################################
    # for quick debugging
    spyreturn, riskfreerate = web_scraping(stock_tickers)
    spyreturn = '{:.4f}'.format(spyreturn)
    spyreturn = float(spyreturn)
    print(quote_data)
    print(spyreturn)
    #############################################################################
    stock_metrics = [['' for m in range(1)] for i in range(len(stock_tickers) * 3)]
    spdr_string = str(spyreturn) + str('%')
    spdr_list = ["Daily return of $SPY", spdr_string]

    stock_index = 0
    for stock in stock_tickers:
        # the average max holdings of each stock is limited at 10% of the portfolio
        trade_size_relative_to_portfolio = 0.1
        beta = trade_size_relative_to_portfolio * float(quote_data[stock]['beta'])
        buying_power = float(account.buying_power) / 4
        stock_profit_pct = round((profit_per_symbol[stock] / buying_power) * 100, 4)
        market_returns_pct = quote_data[stock]['returns']
        # divide the 1 month risk free rate by 30 to approximate the rate of bond return for 1 day
        alpha = round((stock_profit_pct - (riskfreerate / 30)) - (beta * (spyreturn - (riskfreerate / 30))), 4)

        list1 = ["Performance of {}:".format(stock), str(market_returns_pct) + str('%')]
        list2 = ["Performance of {} relative to $SPY:".format(stock), str(round(market_returns_pct - spyreturn, 2)) +
                 str('%')]
        list3 = ["\"Alpha\" trading performance of {}:".format(stock), str(alpha) + str('%')]

        stock_metrics[stock_index] = list1
        stock_metrics[stock_index + 1] = list2
        stock_metrics[stock_index + 2] = list3

        print(list1)
        print(list2)
        print(list3)
        stock_index += 3

    # if the total gross profit of the stock is not positive then the gross loss must be flipped in order to generate a
    # non negative percentage for the profit factor of the portfolio
    if total_gross_profit > -total_gross_loss:
        total_profit_factor = round((total_gross_profit / -total_gross_loss), 2)
    else:
        total_profit_factor = round((total_gross_profit / total_gross_loss), 2)

    if long_gross_profit > -long_gross_loss:
        long_profit_factor = round((long_gross_profit / -long_gross_loss), 2)
    else:
        long_profit_factor = round((long_gross_profit / long_gross_loss), 2)

    if short_gross_profit > -short_gross_loss:
        short_profit_factor = round((short_gross_profit / -short_gross_loss), 2)
    else:
        short_profit_factor = round((short_gross_profit / short_gross_loss), 2)

    total_percent_profitable = round(((long_winning_trades + short_winning_trades) / (total_long_trades +
                                                                                      total_short_trades)) * 100, 2)
    long_percent_profitable = round((long_winning_trades / total_long_trades) * 100, 2)
    short_percent_profitable = round((short_winning_trades / total_short_trades) * 100, 2)
    no_of_stock_metrics = len(stock_metrics)

    # this is the 2d list used to convert into a pandas dataframe for easy transcription onto an excel document
    data = [['Profit Metrics', '', '', ''],
            ['Total Net Profit:', todays_profit_and_loss, net_long_profit, net_short_profit],
            ['Gross Profit:', total_gross_profit, long_gross_profit, short_gross_profit],
            ['Gross Loss:', total_gross_loss, long_gross_loss, short_gross_loss],
            ['Profit Factor:', total_profit_factor, long_profit_factor, short_profit_factor],
            ['', '', '', ''],
            ['Trade Metrics', '', '', ''],
            ['Total Number of Trades:', int(total_long_trades + total_short_trades), total_long_trades,
             total_short_trades],
            ['Percent Profitable:', str(total_percent_profitable) + str("%"), str(long_percent_profitable) + str('%'),
             str(short_percent_profitable) + str('%')],
            ['Average Stock Held Time (Seconds):', avg_total_trade_length, avg_long_trade_length,
             avg_short_trade_length],
            ['Winning Trades:', long_winning_trades + short_winning_trades, long_winning_trades, short_winning_trades],
            ['Average Winning Trade:', avg_winning_trade, avg_long_winning_trade, avg_short_winning_trade],
            ['Losing Trades:', long_losing_trades + short_losing_trades, long_losing_trades, short_losing_trades],
            ['Average Losing Trade:', avg_losing_trade, avg_long_losing_trade, avg_short_losing_trade],
            ['Even Trades', long_even_trades + short_even_trades, long_even_trades, short_even_trades],
            ['', '', '', ''],
            ['Stock Metrics', '', '', ''],
            spdr_list] + stock_metrics

    # if i want to add further rows in the future, simply do
    # data + 2d list

    portfolio_metrics = DataFrame(data, columns=['Performance Summary', 'All Trades', 'Long Trades', 'Short Trades'])
    sheet_name = str('Performance on ') + str(date)
    data_to_excel(portfolio_metrics)
    formatting_excel(sheet_name)
